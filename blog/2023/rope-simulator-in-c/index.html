<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd"> <html><body> <figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*l1i7Gfh5q1wUPq15"><figcaption>Photo by <a href="https://unsplash.com/@meganmenegay?utm_source=medium&amp;utm_medium=referral" rel="external nofollow noopener" target="_blank">Megan Menegay</a> on <a href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="external nofollow noopener" target="_blank">Unsplash</a></figcaption></figure> <p>For some time now, I’ve been missing quick and to-the-point tutorials on particle-based physics simulations. Hence, I decided to start sharing things I learned in a concise manner. For starters, we’re going to implement a simple rope simulator. However, before we do anything, a quick disclaimer.</p> <p><em>This tutorial is aimed at achieving rapid, visual results. I do not follow perfect software engineering practices and do not explain the math in-depth.</em></p> <p>Now that you’ve been warned, let’s get to it!</p> <h3>What is a rope?</h3> <p>What rope is, everybody sees. In order to create a digital representation of one, we divide it into multiple small segments, connected by points. Since rope and spring are two different things, those segments have equal and constant lengths — <em>D</em>.</p> <figure><img alt="Process of splitting a rope into equal segments in order to create its digital representation" src="https://cdn-images-1.medium.com/max/980/1*OOl6Q55HxhJ1lqCfqiGHWg.png"><figcaption>Splitting a rope into equal segments</figcaption></figure> <p>This representation lets us focus on individual points (or particles) and their properties.</p> <h3><strong>A bit of math</strong></h3> <p>Now that we have the representation of a rope, how can we simulate it? First, we need to update the positions of each point based on the forces applied to the rope, such as gravity. Then, we need to make sure that our rope does not stretch or compress.</p> <h4>Verlet Integration</h4> <p>You’re probably familiar with the simplest of all — Euler integration. At a certain timestep, you update velocity based on acceleration and then update position based on velocity. We need to define a step size, for example, 0.01 seconds. In a more formal way, this method looks like this.</p> <figure><img alt="" src="https://cdn-images-1.medium.com/max/608/1*e_EIBfMeLTPGhM6OGoJAuA.png"></figure> <figure><img alt="" src="https://cdn-images-1.medium.com/max/682/1*N0Tt63a0XmibJZlpT78LGQ.png"></figure> <p>Everything looks great, but over time we lose a lot of precision, and the accuracy of the simulation is highly dependent on the chosen timestep. If you wanna see more details, please see <a href="https://owlree.blog/posts/simulating-a-rope.html" rel="external nofollow noopener" target="_blank">this post</a>. This issue brings us to Verlet integration, which is more stable and accurate. The basic idea is the following, we update our position based on the previous and instant velocity. I won’t derive the whole formula, cause it takes a bit of time to get right. In short, it looks like this.</p> <figure><img alt="" src="https://cdn-images-1.medium.com/max/888/1*CozwbUSR-mV4581eRPuLbA.png"></figure> <p>After we repeat this procedure for every particle, we have successfully calculated the new state of the rope at the next time step. However, there is a problem. We might end up in a situation, where segments have different lengths. This can happen whenever two opposing forces are acting on neighboring particles. Let’s enforce this constraint!</p> <h4>Enforcing constraints</h4> <p>After the Verlet integration, segments may be slightly shorter or longer than before. In the beginning, we defined <em>D </em>to be our target segment length. This means, that if our rope consists of 10 particles, 9 segments, and <em>D=1</em>, then the rope should be 9 units long <strong>at all times</strong>. To make sure this is the case, we use the Jakobsen method. This method is used whenever a constraint of fixed distance between particles needs to be enforced, so feel free to use it in other projects, such as cloth simulations!</p> <p>Let’s get to the algorithm. We take two particles <em>(p,q)</em> connected by a segment of length <em>d=||p-q||</em>. If <em>d</em> is smaller than the desired distance <em>D</em>, we push particles apart, each by <em>0.5(D-d)</em>. If they are too far, we do the opposite, we pull them closer, each by <em>0.5(d-D)</em>. Tricky things happen when a certain point is fixed. Think of it, as if the rope was pinned to the wall throughout the simulation. Then, we cannot move this particle around while enforcing constraint, hence we drop the <em>0.5</em> factor and move the neighboring particle by <em>|d-D|</em> in the appropriate direction. By repeating this procedure multiple times, our segments should have approximately appropriate lengths.</p> <figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*CwHxvmnBl5-ylr2z1bm5_A.png"><figcaption>A single iteration of enforcing constraints. Note that the particle at the top is fixed</figcaption></figure> <h3>Code</h3> <p><a href="https://gist.github.com/fszewczyk/46915c02a34a1833d83a3c2fd851b7a0" rel="external nofollow noopener" target="_blank"><em>Available on GitHub</em></a></p> <p>Finally, we are ready to code it up. I will do it in C++, but feel free to use whatever you like. The translation should be rather easy.</p> <p>First and foremost, let’s import the necessary libraries and put some global constants in place.</p> <pre>#include &lt;math.h&gt;<br>#include &lt;stdlib.h&gt;<br>#include &lt;vector&gt;<br><br>float GRAVITY = -9.81;             // constant force applied to all particles<br>float TIMESTEP = 0.01;             // Δt in our equations<br>unsigned JAKOBSEN_ITERATIONS = 50; // Number of times we will enforce the distance constraint</pre> <p>For convenience, let’s define a particle. Remember, we need to keep track of its previous position in order to perform Verlet integration.</p> <pre>struct Particle {<br>    // Current position<br>    float x;<br>    float y;<br><br>    // Previous position<br>    float xPrevious;<br>    float yPrevious;<br><br>    // Whether or not particle is able to move<br>    bool fixed;<br>};</pre> <p>We will enclose the whole functionality in a class called Rope. I’ll define a simple constructor that creates a rope between two points. The first point will be fixed, while all others not. Depending on the application, we also want to control the total number of particles in a rope.</p> <pre>class Rope {<br>  public:<br>    Rope(float x1, float y1, float x2, float y2, unsigned nParticles) {<br>        for (unsigned i = 0; i &lt; nParticles; i++) {<br>            // How close are we to the last point?<br>            float w = (float)i / (nParticles - 1);<br><br>            float x = w * x2 + (1 - w) * x1;<br>            float y = w * y2 + (1 - w) * y1;<br><br>            Particle p;<br>            p.x = x;<br>            p.y = y;<br>            p.xPrevious = x;<br>            p.yPrevious = y;<br>            p.fixed = i == 0; // We fix only the first point<br><br>            _particles.push_back(p);<br>        }<br><br>        // There is one less segment than there are particles<br>        unsigned numberOfSegments = nParticles - 1;<br>        float ropeLength = sqrt(pow(x1 - x2, 2) + pow(y1 - y2, 2));<br><br>        _desiredDistance = ropeLength / numberOfSegments;<br>    }<br><br>  private:<br>    // We need to store our particles somewhere<br>    std::vector&lt;Particle&gt; _particles;<br><br>    // Target distance of a single segment<br>    float _desiredDistance;<br>};</pre> <p>To advance the simulation by one step, we define a public function step. As we discussed, a single step consists of a Verlet integration and Jakobsen constraint enforcement.</p> <pre>void step() {<br>    verletIntegration();<br>    enforceConstraints();<br>}</pre> <p>Let’s define a private method verletIntegration, that will take care of the fancy math.</p> <pre>void verletIntegration(){<br>    for (Particle &amp;p : _particles){<br>        if(p.fixed)<br>            continue; // We do not want to move fixed particles<br>        float xCopy = p.x;<br>        float yCopy = p.y;<br><br>        // Updating particle's position<br>        p.x = 2 * p.x - p.xPrevious + 0 * TIMESTEP * TIMESTEP;<br>        p.y = 2 * p.y - p.yPrevious + GRAVITY* TIMESTEP * TIMESTEP;<br><br>        p.xPrevious = xCopy;<br>        p.yPrevious = yCopy;<br>    }<br>}</pre> <p>Perfect! Let’s enforce those constraints. We define another private method enforceConstraints.</p> <pre>void enforceConstraints(){<br>    // We perform the enforcement multiple times<br>    for (unsigned iteration = 0; iteration &lt; JAKOBSEN_ITERATIONS; iteration++){<br>        // We iterate over each pair of pa<br>        for (size_t i = 1; i &lt; _particles.size(); i++) {<br>            Particle &amp;p1 = _particles[i-1];<br>            Particle &amp;p2 = _particles[i];<br>            <br>            // Calculating distance between the particles<br>            float distance = sqrt(pow(p1.x - p2.x, 2) + pow(p1.y - p2.y, 2));<br>            float distanceError = distance - _desiredDistance;<br><br>            // The direction in which particles should be pulled or pushed<br>            float xDifference = p2.x - p1.x;<br>            float yDifference = p2.y - p1.y;<br><br>            // We need to make it a unit vector<br>            // This will allow us to easily scale the impact we have<br>            // on each particle's position.<br>            float xDirection = xDifference / sqrt(pow(xDifference, 2) + pow(yDifference, 2));<br>            float yDirection = yDifference / sqrt(pow(xDifference, 2) + pow(yDifference, 2));<br><br>            // Finally, we can update particles' positions<br>            // We need to remember that fixed particles should stay in place<br>            if (p1.fixed &amp;&amp; !p2.fixed) {<br>                p2.x -= xDirection * distanceError;<br>                p2.y -= yDirection * distanceError;<br>            } else if (p2.fixed &amp;&amp; !p1.fixed) {<br>                p1.x += xDirection * distanceError;<br>                p1.y += yDirection * distanceError;<br>            } else if (!p1.fixed &amp;&amp; !p2.fixed){<br>                p2.x -= 0.5 * xDirection * distanceError;<br>                p2.y -= 0.5 * yDirection * distanceError;<br>                p1.x += 0.5 * xDirection * distanceError;<br>                p1.y += 0.5 * yDirection * distanceError;<br>            }<br>        }<br>    }<br>}</pre> <p>That’s it! Please see the <a href="https://gist.github.com/fszewczyk/46915c02a34a1833d83a3c2fd851b7a0" rel="external nofollow noopener" target="_blank">GitHub Gist</a> for the whole code. Our simulator is ready to be used. To show its functionality, I implemented a Python interface using <a href="https://pybind11.readthedocs.io/en/stable/index.html" rel="external nofollow noopener" target="_blank">pybind11</a> and created an animated plot using <a href="https://matplotlib.org/" rel="external nofollow noopener" target="_blank">matplotlib</a> and <a href="https://pypi.org/project/plot2vid/" rel="external nofollow noopener" target="_blank">plot2vid</a>.</p> <figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*YHwPJFarsbnw9t4cvxN-ew.gif"></figure> <p>Turns out that the technique I described is much more powerful than just ropes. You can easily transform this code to create more fun stuff, including cloths and solid bodies. For inspiration, check out <a href="https://jlpaca.github.io/toybox/6-jakobsen/index.html" rel="external nofollow noopener" target="_blank">this website</a>.</p> <h3>References and further reading</h3> <ol> <li><a href="https://owlree.blog/posts/simulating-a-rope.html" rel="external nofollow noopener" target="_blank">Very detailed explanation of this algorithm</a></li> <li><a href="https://jlpaca.github.io/toybox/6-jakobsen/index.html" rel="external nofollow noopener" target="_blank">Fun examples of Jakobsen Particle Simulation</a></li> <li><a href="https://www.cs.cmu.edu/afs/cs/academic/class/15462-s13/www/lec_slides/Jakobsen.pdf" rel="external nofollow noopener" target="_blank">A comprehensive tutorial on Jakobsen Constraints by Jakobsen himself</a></li> </ol> <p><img src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=a595a3ef956c" width="1" height="1" alt=""></p> </body></html>